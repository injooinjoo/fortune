# [3.1] 운세 페이지 정렬 개선 기획서

## 1. 현황 분석

### 1.1 현재 정렬 옵션 (fortune_order_provider.dart)
| 옵션 | 설명 | 정렬 기준 |
|------|------|----------|
| `custom` | 사용자 지정 | 드래그 앤 드롭 순서 |
| `recentlyViewed` | 최근 조회순 | lastViewed 타임스탬프 |
| `availableFirst` | 조회 가능순 | 오늘 안 본 것 우선 |
| `favoriteFirst` | 즐겨찾기 우선 | favorites Set |

### 1.2 데이터 저장 구조
```dart
class FortuneOrderState {
  final List<String> customOrder;        // 사용자 드래그 순서
  final Set<String> favorites;           // 즐겨찾기
  final SortOption currentSort;          // 현재 정렬
  final Map<String, DateTime> lastViewed; // 마지막 조회 시간
}
```

### 1.3 요청사항
> "노출 순서: 인기순 > 조회수 > 즐겨찾기"

## 2. 문제 정의

### 2.1 "인기순" 정의 불명확
- **글로벌 인기**: 전체 사용자 기준 많이 본 운세
- **개인 인기**: 해당 사용자가 자주 본 운세

### 2.2 데이터 가용성
| 데이터 | 현재 상태 | 저장 위치 |
|--------|----------|----------|
| 글로벌 인기 | ❌ 없음 | DB 집계 필요 |
| 개인 조회수 | ⚠️ 부분 | lastViewed (날짜만) |
| 즐겨찾기 | ✅ 있음 | SharedPreferences |

## 3. 구현 방안

### 3.1 Option A: 순수 로컬 (권장)

**개념**: "인기순 > 조회수 > 즐겨찾기" 복합 정렬을 단일 옵션으로 구현

**데이터 추가**:
```dart
class FortuneOrderState {
  // 기존 필드...
  final Map<String, int> viewCount;  // 누적 조회수 (NEW)
}
```

**정렬 알고리즘**:
```
점수 = (조회수 × 10) + (즐겨찾기 ? 100 : 0) + (isNew ? 50 : 0)
```

**장점**:
- DB 변경 불필요
- 오프라인 동작
- 즉시 적용 가능

**단점**:
- 글로벌 인기 반영 불가
- 새 사용자는 기본 순서

### 3.2 Option B: 하이브리드 (향후 고려)

**개념**: 기본 인기도 가중치 + 개인 조회수

```dart
// 기본 인기도 (정적 데이터)
const Map<String, int> defaultPopularity = {
  'daily': 100,      // 가장 인기
  'tarot': 90,
  'love': 85,
  'compatibility': 80,
  // ...
};

// 최종 점수 = 기본인기도 + (개인조회수 × 5) + (즐겨찾기 × 50)
```

## 4. 선택: Option A 구현

### 4.1 UI 변경
기존 4개 → 5개 정렬 옵션:

| 순서 | 옵션명 | 설명 |
|------|--------|------|
| 1 | **추천순** (NEW) | 인기 + 조회수 + 즐겨찾기 복합 |
| 2 | 최근 조회순 | 기존 유지 |
| 3 | 조회 가능순 | 기존 유지 |
| 4 | 즐겨찾기 | 기존 유지 |
| 5 | 사용자 지정 | 기존 유지 |

### 4.2 코드 변경

**파일 1: fortune_order_provider.dart**
```dart
// 1. Enum 추가
enum SortOption {
  recommended,    // NEW: 추천순 (인기+조회+즐겨찾기)
  custom,
  recentlyViewed,
  availableFirst,
  favoriteFirst,
}

// 2. State에 viewCount 추가
class FortuneOrderState {
  final Map<String, int> viewCount;  // NEW
  // ... 기존 필드
}

// 3. 추천순 정렬 메서드 추가
List<FortuneCategory> _sortByRecommended(List<FortuneCategory> categories) {
  final sorted = List<FortuneCategory>.from(categories);
  sorted.sort((a, b) {
    final aScore = _calculateScore(a);
    final bScore = _calculateScore(b);
    return bScore.compareTo(aScore);
  });
  return sorted;
}

int _calculateScore(FortuneCategory category) {
  final views = state.viewCount[category.type] ?? 0;
  final isFavorite = state.favorites.contains(category.type);
  final isNewCategory = category.isNew;

  return (views * 10) + (isFavorite ? 100 : 0) + (isNewCategory ? 50 : 0);
}
```

**파일 2: fortune_list_page.dart**
```dart
// 정렬 옵션 UI에 "추천순" 추가
_buildSortOption(
  context,
  '추천순',
  '인기 + 조회수 + 즐겨찾기 기반',
  SortOption.recommended,
  currentSort == SortOption.recommended,
),
```

### 4.3 데이터 마이그레이션
- viewCount 초기값: 기존 lastViewed 키 기반으로 1 설정
- 기존 사용자의 데이터 유지

## 5. 구현 체크리스트

- [ ] `SortOption` enum에 `recommended` 추가
- [ ] `FortuneOrderState`에 `viewCount` Map 추가
- [ ] `_loadFromPreferences`에서 viewCount 로드
- [ ] `_saveToPreferences`에서 viewCount 저장
- [ ] `recordView` 메서드에서 viewCount 증가
- [ ] `_sortByRecommended` 정렬 메서드 구현
- [ ] `_calculateScore` 점수 계산 로직 구현
- [ ] `getSortedCategories`에 recommended 케이스 추가
- [ ] UI: 정렬 옵션 바텀시트에 "추천순" 추가
- [ ] 기존 default를 custom → recommended로 변경
- [ ] flutter analyze 검증

## 6. 테스트 시나리오

1. **신규 사용자**: isNew 카테고리가 상단에 표시
2. **기존 사용자**: 자주 본 운세 + 즐겨찾기 상단
3. **즐겨찾기 토글**: 점수 변화 확인
4. **운세 조회 후**: 해당 운세 점수 증가 확인

## 7. 예상 결과

### 정렬 점수 예시
| 운세 | 조회수 | 즐겨찾기 | isNew | 점수 |
|------|--------|----------|-------|------|
| 타로 | 15 | ✅ | ✅ | 300 |
| 사주 | 20 | ✅ | ❌ | 300 |
| 연애 | 10 | ❌ | ✅ | 150 |
| MBTI | 5 | ❌ | ✅ | 100 |
| 건강 | 3 | ❌ | ❌ | 30 |

---
**작성일**: 2025-12-17
**예상 소요**: 30분