// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'widget_fortune_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

WidgetFortuneData _$WidgetFortuneDataFromJson(Map<String, dynamic> json) {
  return _WidgetFortuneData.fromJson(json);
}

/// @nodoc
mixin _$WidgetFortuneData {
  String get type => throw _privateConstructorUsedError;
  String get icon => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get lastUpdated => throw _privateConstructorUsedError;
  String? get score => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  String? get percentile => throw _privateConstructorUsedError;
  Map<String, dynamic>? get extraData => throw _privateConstructorUsedError;

  /// Serializes this WidgetFortuneData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WidgetFortuneData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WidgetFortuneDataCopyWith<WidgetFortuneData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WidgetFortuneDataCopyWith<$Res> {
  factory $WidgetFortuneDataCopyWith(
          WidgetFortuneData value, $Res Function(WidgetFortuneData) then) =
      _$WidgetFortuneDataCopyWithImpl<$Res, WidgetFortuneData>;
  @useResult
  $Res call(
      {String type,
      String icon,
      String title,
      String lastUpdated,
      String? score,
      String? message,
      String? percentile,
      Map<String, dynamic>? extraData});
}

/// @nodoc
class _$WidgetFortuneDataCopyWithImpl<$Res, $Val extends WidgetFortuneData>
    implements $WidgetFortuneDataCopyWith<$Res> {
  _$WidgetFortuneDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WidgetFortuneData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? icon = null,
    Object? title = null,
    Object? lastUpdated = null,
    Object? score = freezed,
    Object? message = freezed,
    Object? percentile = freezed,
    Object? extraData = freezed,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      icon: null == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      lastUpdated: null == lastUpdated
          ? _value.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as String,
      score: freezed == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      percentile: freezed == percentile
          ? _value.percentile
          : percentile // ignore: cast_nullable_to_non_nullable
              as String?,
      extraData: freezed == extraData
          ? _value.extraData
          : extraData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WidgetFortuneDataImplCopyWith<$Res>
    implements $WidgetFortuneDataCopyWith<$Res> {
  factory _$$WidgetFortuneDataImplCopyWith(_$WidgetFortuneDataImpl value,
          $Res Function(_$WidgetFortuneDataImpl) then) =
      __$$WidgetFortuneDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String type,
      String icon,
      String title,
      String lastUpdated,
      String? score,
      String? message,
      String? percentile,
      Map<String, dynamic>? extraData});
}

/// @nodoc
class __$$WidgetFortuneDataImplCopyWithImpl<$Res>
    extends _$WidgetFortuneDataCopyWithImpl<$Res, _$WidgetFortuneDataImpl>
    implements _$$WidgetFortuneDataImplCopyWith<$Res> {
  __$$WidgetFortuneDataImplCopyWithImpl(_$WidgetFortuneDataImpl _value,
      $Res Function(_$WidgetFortuneDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of WidgetFortuneData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? icon = null,
    Object? title = null,
    Object? lastUpdated = null,
    Object? score = freezed,
    Object? message = freezed,
    Object? percentile = freezed,
    Object? extraData = freezed,
  }) {
    return _then(_$WidgetFortuneDataImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      icon: null == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      lastUpdated: null == lastUpdated
          ? _value.lastUpdated
          : lastUpdated // ignore: cast_nullable_to_non_nullable
              as String,
      score: freezed == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      percentile: freezed == percentile
          ? _value.percentile
          : percentile // ignore: cast_nullable_to_non_nullable
              as String?,
      extraData: freezed == extraData
          ? _value._extraData
          : extraData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$WidgetFortuneDataImpl implements _WidgetFortuneData {
  const _$WidgetFortuneDataImpl(
      {required this.type,
      required this.icon,
      required this.title,
      required this.lastUpdated,
      this.score,
      this.message,
      this.percentile,
      final Map<String, dynamic>? extraData})
      : _extraData = extraData;

  factory _$WidgetFortuneDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$WidgetFortuneDataImplFromJson(json);

  @override
  final String type;
  @override
  final String icon;
  @override
  final String title;
  @override
  final String lastUpdated;
  @override
  final String? score;
  @override
  final String? message;
  @override
  final String? percentile;
  final Map<String, dynamic>? _extraData;
  @override
  Map<String, dynamic>? get extraData {
    final value = _extraData;
    if (value == null) return null;
    if (_extraData is EqualUnmodifiableMapView) return _extraData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'WidgetFortuneData(type: $type, icon: $icon, title: $title, lastUpdated: $lastUpdated, score: $score, message: $message, percentile: $percentile, extraData: $extraData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetFortuneDataImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.icon, icon) || other.icon == icon) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.lastUpdated, lastUpdated) ||
                other.lastUpdated == lastUpdated) &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.percentile, percentile) ||
                other.percentile == percentile) &&
            const DeepCollectionEquality()
                .equals(other._extraData, _extraData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      type,
      icon,
      title,
      lastUpdated,
      score,
      message,
      percentile,
      const DeepCollectionEquality().hash(_extraData));

  /// Create a copy of WidgetFortuneData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetFortuneDataImplCopyWith<_$WidgetFortuneDataImpl> get copyWith =>
      __$$WidgetFortuneDataImplCopyWithImpl<_$WidgetFortuneDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WidgetFortuneDataImplToJson(
      this,
    );
  }
}

abstract class _WidgetFortuneData implements WidgetFortuneData {
  const factory _WidgetFortuneData(
      {required final String type,
      required final String icon,
      required final String title,
      required final String lastUpdated,
      final String? score,
      final String? message,
      final String? percentile,
      final Map<String, dynamic>? extraData}) = _$WidgetFortuneDataImpl;

  factory _WidgetFortuneData.fromJson(Map<String, dynamic> json) =
      _$WidgetFortuneDataImpl.fromJson;

  @override
  String get type;
  @override
  String get icon;
  @override
  String get title;
  @override
  String get lastUpdated;
  @override
  String? get score;
  @override
  String? get message;
  @override
  String? get percentile;
  @override
  Map<String, dynamic>? get extraData;

  /// Create a copy of WidgetFortuneData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WidgetFortuneDataImplCopyWith<_$WidgetFortuneDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DailyWidgetData _$DailyWidgetDataFromJson(Map<String, dynamic> json) {
  return _DailyWidgetData.fromJson(json);
}

/// @nodoc
mixin _$DailyWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get luckyColor => throw _privateConstructorUsedError;
  String? get luckyNumber => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  String? get percentile => throw _privateConstructorUsedError;

  /// Serializes this DailyWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DailyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DailyWidgetDataCopyWith<DailyWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DailyWidgetDataCopyWith<$Res> {
  factory $DailyWidgetDataCopyWith(
          DailyWidgetData value, $Res Function(DailyWidgetData) then) =
      _$DailyWidgetDataCopyWithImpl<$Res, DailyWidgetData>;
  @useResult
  $Res call(
      {String score,
      String? luckyColor,
      String? luckyNumber,
      String? message,
      String? percentile});
}

/// @nodoc
class _$DailyWidgetDataCopyWithImpl<$Res, $Val extends DailyWidgetData>
    implements $DailyWidgetDataCopyWith<$Res> {
  _$DailyWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DailyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? luckyColor = freezed,
    Object? luckyNumber = freezed,
    Object? message = freezed,
    Object? percentile = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      luckyColor: freezed == luckyColor
          ? _value.luckyColor
          : luckyColor // ignore: cast_nullable_to_non_nullable
              as String?,
      luckyNumber: freezed == luckyNumber
          ? _value.luckyNumber
          : luckyNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      percentile: freezed == percentile
          ? _value.percentile
          : percentile // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DailyWidgetDataImplCopyWith<$Res>
    implements $DailyWidgetDataCopyWith<$Res> {
  factory _$$DailyWidgetDataImplCopyWith(_$DailyWidgetDataImpl value,
          $Res Function(_$DailyWidgetDataImpl) then) =
      __$$DailyWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String score,
      String? luckyColor,
      String? luckyNumber,
      String? message,
      String? percentile});
}

/// @nodoc
class __$$DailyWidgetDataImplCopyWithImpl<$Res>
    extends _$DailyWidgetDataCopyWithImpl<$Res, _$DailyWidgetDataImpl>
    implements _$$DailyWidgetDataImplCopyWith<$Res> {
  __$$DailyWidgetDataImplCopyWithImpl(
      _$DailyWidgetDataImpl _value, $Res Function(_$DailyWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of DailyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? luckyColor = freezed,
    Object? luckyNumber = freezed,
    Object? message = freezed,
    Object? percentile = freezed,
  }) {
    return _then(_$DailyWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      luckyColor: freezed == luckyColor
          ? _value.luckyColor
          : luckyColor // ignore: cast_nullable_to_non_nullable
              as String?,
      luckyNumber: freezed == luckyNumber
          ? _value.luckyNumber
          : luckyNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      percentile: freezed == percentile
          ? _value.percentile
          : percentile // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DailyWidgetDataImpl implements _DailyWidgetData {
  const _$DailyWidgetDataImpl(
      {required this.score,
      this.luckyColor,
      this.luckyNumber,
      this.message,
      this.percentile});

  factory _$DailyWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$DailyWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? luckyColor;
  @override
  final String? luckyNumber;
  @override
  final String? message;
  @override
  final String? percentile;

  @override
  String toString() {
    return 'DailyWidgetData(score: $score, luckyColor: $luckyColor, luckyNumber: $luckyNumber, message: $message, percentile: $percentile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DailyWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.luckyColor, luckyColor) ||
                other.luckyColor == luckyColor) &&
            (identical(other.luckyNumber, luckyNumber) ||
                other.luckyNumber == luckyNumber) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.percentile, percentile) ||
                other.percentile == percentile));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, score, luckyColor, luckyNumber, message, percentile);

  /// Create a copy of DailyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DailyWidgetDataImplCopyWith<_$DailyWidgetDataImpl> get copyWith =>
      __$$DailyWidgetDataImplCopyWithImpl<_$DailyWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DailyWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _DailyWidgetData implements DailyWidgetData {
  const factory _DailyWidgetData(
      {required final String score,
      final String? luckyColor,
      final String? luckyNumber,
      final String? message,
      final String? percentile}) = _$DailyWidgetDataImpl;

  factory _DailyWidgetData.fromJson(Map<String, dynamic> json) =
      _$DailyWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get luckyColor;
  @override
  String? get luckyNumber;
  @override
  String? get message;
  @override
  String? get percentile;

  /// Create a copy of DailyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DailyWidgetDataImplCopyWith<_$DailyWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LoveWidgetData _$LoveWidgetDataFromJson(Map<String, dynamic> json) {
  return _LoveWidgetData.fromJson(json);
}

/// @nodoc
mixin _$LoveWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get goodDay => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this LoveWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LoveWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LoveWidgetDataCopyWith<LoveWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoveWidgetDataCopyWith<$Res> {
  factory $LoveWidgetDataCopyWith(
          LoveWidgetData value, $Res Function(LoveWidgetData) then) =
      _$LoveWidgetDataCopyWithImpl<$Res, LoveWidgetData>;
  @useResult
  $Res call({String score, String? goodDay, String? message});
}

/// @nodoc
class _$LoveWidgetDataCopyWithImpl<$Res, $Val extends LoveWidgetData>
    implements $LoveWidgetDataCopyWith<$Res> {
  _$LoveWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LoveWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? goodDay = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      goodDay: freezed == goodDay
          ? _value.goodDay
          : goodDay // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LoveWidgetDataImplCopyWith<$Res>
    implements $LoveWidgetDataCopyWith<$Res> {
  factory _$$LoveWidgetDataImplCopyWith(_$LoveWidgetDataImpl value,
          $Res Function(_$LoveWidgetDataImpl) then) =
      __$$LoveWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? goodDay, String? message});
}

/// @nodoc
class __$$LoveWidgetDataImplCopyWithImpl<$Res>
    extends _$LoveWidgetDataCopyWithImpl<$Res, _$LoveWidgetDataImpl>
    implements _$$LoveWidgetDataImplCopyWith<$Res> {
  __$$LoveWidgetDataImplCopyWithImpl(
      _$LoveWidgetDataImpl _value, $Res Function(_$LoveWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoveWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? goodDay = freezed,
    Object? message = freezed,
  }) {
    return _then(_$LoveWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      goodDay: freezed == goodDay
          ? _value.goodDay
          : goodDay // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LoveWidgetDataImpl implements _LoveWidgetData {
  const _$LoveWidgetDataImpl({required this.score, this.goodDay, this.message});

  factory _$LoveWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$LoveWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? goodDay;
  @override
  final String? message;

  @override
  String toString() {
    return 'LoveWidgetData(score: $score, goodDay: $goodDay, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoveWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.goodDay, goodDay) || other.goodDay == goodDay) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, goodDay, message);

  /// Create a copy of LoveWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoveWidgetDataImplCopyWith<_$LoveWidgetDataImpl> get copyWith =>
      __$$LoveWidgetDataImplCopyWithImpl<_$LoveWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LoveWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _LoveWidgetData implements LoveWidgetData {
  const factory _LoveWidgetData(
      {required final String score,
      final String? goodDay,
      final String? message}) = _$LoveWidgetDataImpl;

  factory _LoveWidgetData.fromJson(Map<String, dynamic> json) =
      _$LoveWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get goodDay;
  @override
  String? get message;

  /// Create a copy of LoveWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoveWidgetDataImplCopyWith<_$LoveWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CareerWidgetData _$CareerWidgetDataFromJson(Map<String, dynamic> json) {
  return _CareerWidgetData.fromJson(json);
}

/// @nodoc
mixin _$CareerWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get luckyTime => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this CareerWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CareerWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CareerWidgetDataCopyWith<CareerWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CareerWidgetDataCopyWith<$Res> {
  factory $CareerWidgetDataCopyWith(
          CareerWidgetData value, $Res Function(CareerWidgetData) then) =
      _$CareerWidgetDataCopyWithImpl<$Res, CareerWidgetData>;
  @useResult
  $Res call({String score, String? luckyTime, String? message});
}

/// @nodoc
class _$CareerWidgetDataCopyWithImpl<$Res, $Val extends CareerWidgetData>
    implements $CareerWidgetDataCopyWith<$Res> {
  _$CareerWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CareerWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? luckyTime = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      luckyTime: freezed == luckyTime
          ? _value.luckyTime
          : luckyTime // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CareerWidgetDataImplCopyWith<$Res>
    implements $CareerWidgetDataCopyWith<$Res> {
  factory _$$CareerWidgetDataImplCopyWith(_$CareerWidgetDataImpl value,
          $Res Function(_$CareerWidgetDataImpl) then) =
      __$$CareerWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? luckyTime, String? message});
}

/// @nodoc
class __$$CareerWidgetDataImplCopyWithImpl<$Res>
    extends _$CareerWidgetDataCopyWithImpl<$Res, _$CareerWidgetDataImpl>
    implements _$$CareerWidgetDataImplCopyWith<$Res> {
  __$$CareerWidgetDataImplCopyWithImpl(_$CareerWidgetDataImpl _value,
      $Res Function(_$CareerWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of CareerWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? luckyTime = freezed,
    Object? message = freezed,
  }) {
    return _then(_$CareerWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      luckyTime: freezed == luckyTime
          ? _value.luckyTime
          : luckyTime // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CareerWidgetDataImpl implements _CareerWidgetData {
  const _$CareerWidgetDataImpl(
      {required this.score, this.luckyTime, this.message});

  factory _$CareerWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$CareerWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? luckyTime;
  @override
  final String? message;

  @override
  String toString() {
    return 'CareerWidgetData(score: $score, luckyTime: $luckyTime, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CareerWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.luckyTime, luckyTime) ||
                other.luckyTime == luckyTime) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, luckyTime, message);

  /// Create a copy of CareerWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CareerWidgetDataImplCopyWith<_$CareerWidgetDataImpl> get copyWith =>
      __$$CareerWidgetDataImplCopyWithImpl<_$CareerWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CareerWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _CareerWidgetData implements CareerWidgetData {
  const factory _CareerWidgetData(
      {required final String score,
      final String? luckyTime,
      final String? message}) = _$CareerWidgetDataImpl;

  factory _CareerWidgetData.fromJson(Map<String, dynamic> json) =
      _$CareerWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get luckyTime;
  @override
  String? get message;

  /// Create a copy of CareerWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CareerWidgetDataImplCopyWith<_$CareerWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

InvestmentWidgetData _$InvestmentWidgetDataFromJson(Map<String, dynamic> json) {
  return _InvestmentWidgetData.fromJson(json);
}

/// @nodoc
mixin _$InvestmentWidgetData {
  List<String> get lottoNumbers => throw _privateConstructorUsedError;
  String? get sector => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this InvestmentWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of InvestmentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $InvestmentWidgetDataCopyWith<InvestmentWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvestmentWidgetDataCopyWith<$Res> {
  factory $InvestmentWidgetDataCopyWith(InvestmentWidgetData value,
          $Res Function(InvestmentWidgetData) then) =
      _$InvestmentWidgetDataCopyWithImpl<$Res, InvestmentWidgetData>;
  @useResult
  $Res call({List<String> lottoNumbers, String? sector, String? message});
}

/// @nodoc
class _$InvestmentWidgetDataCopyWithImpl<$Res,
        $Val extends InvestmentWidgetData>
    implements $InvestmentWidgetDataCopyWith<$Res> {
  _$InvestmentWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InvestmentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lottoNumbers = null,
    Object? sector = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      lottoNumbers: null == lottoNumbers
          ? _value.lottoNumbers
          : lottoNumbers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      sector: freezed == sector
          ? _value.sector
          : sector // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InvestmentWidgetDataImplCopyWith<$Res>
    implements $InvestmentWidgetDataCopyWith<$Res> {
  factory _$$InvestmentWidgetDataImplCopyWith(_$InvestmentWidgetDataImpl value,
          $Res Function(_$InvestmentWidgetDataImpl) then) =
      __$$InvestmentWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> lottoNumbers, String? sector, String? message});
}

/// @nodoc
class __$$InvestmentWidgetDataImplCopyWithImpl<$Res>
    extends _$InvestmentWidgetDataCopyWithImpl<$Res, _$InvestmentWidgetDataImpl>
    implements _$$InvestmentWidgetDataImplCopyWith<$Res> {
  __$$InvestmentWidgetDataImplCopyWithImpl(_$InvestmentWidgetDataImpl _value,
      $Res Function(_$InvestmentWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of InvestmentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lottoNumbers = null,
    Object? sector = freezed,
    Object? message = freezed,
  }) {
    return _then(_$InvestmentWidgetDataImpl(
      lottoNumbers: null == lottoNumbers
          ? _value._lottoNumbers
          : lottoNumbers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      sector: freezed == sector
          ? _value.sector
          : sector // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InvestmentWidgetDataImpl implements _InvestmentWidgetData {
  const _$InvestmentWidgetDataImpl(
      {final List<String> lottoNumbers = const [], this.sector, this.message})
      : _lottoNumbers = lottoNumbers;

  factory _$InvestmentWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$InvestmentWidgetDataImplFromJson(json);

  final List<String> _lottoNumbers;
  @override
  @JsonKey()
  List<String> get lottoNumbers {
    if (_lottoNumbers is EqualUnmodifiableListView) return _lottoNumbers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_lottoNumbers);
  }

  @override
  final String? sector;
  @override
  final String? message;

  @override
  String toString() {
    return 'InvestmentWidgetData(lottoNumbers: $lottoNumbers, sector: $sector, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvestmentWidgetDataImpl &&
            const DeepCollectionEquality()
                .equals(other._lottoNumbers, _lottoNumbers) &&
            (identical(other.sector, sector) || other.sector == sector) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_lottoNumbers), sector, message);

  /// Create a copy of InvestmentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InvestmentWidgetDataImplCopyWith<_$InvestmentWidgetDataImpl>
      get copyWith =>
          __$$InvestmentWidgetDataImplCopyWithImpl<_$InvestmentWidgetDataImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InvestmentWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _InvestmentWidgetData implements InvestmentWidgetData {
  const factory _InvestmentWidgetData(
      {final List<String> lottoNumbers,
      final String? sector,
      final String? message}) = _$InvestmentWidgetDataImpl;

  factory _InvestmentWidgetData.fromJson(Map<String, dynamic> json) =
      _$InvestmentWidgetDataImpl.fromJson;

  @override
  List<String> get lottoNumbers;
  @override
  String? get sector;
  @override
  String? get message;

  /// Create a copy of InvestmentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InvestmentWidgetDataImplCopyWith<_$InvestmentWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MbtiWidgetData _$MbtiWidgetDataFromJson(Map<String, dynamic> json) {
  return _MbtiWidgetData.fromJson(json);
}

/// @nodoc
mixin _$MbtiWidgetData {
  String get mbtiType => throw _privateConstructorUsedError;
  String? get energyLevel => throw _privateConstructorUsedError;
  String? get mood => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this MbtiWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MbtiWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MbtiWidgetDataCopyWith<MbtiWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MbtiWidgetDataCopyWith<$Res> {
  factory $MbtiWidgetDataCopyWith(
          MbtiWidgetData value, $Res Function(MbtiWidgetData) then) =
      _$MbtiWidgetDataCopyWithImpl<$Res, MbtiWidgetData>;
  @useResult
  $Res call(
      {String mbtiType, String? energyLevel, String? mood, String? message});
}

/// @nodoc
class _$MbtiWidgetDataCopyWithImpl<$Res, $Val extends MbtiWidgetData>
    implements $MbtiWidgetDataCopyWith<$Res> {
  _$MbtiWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MbtiWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mbtiType = null,
    Object? energyLevel = freezed,
    Object? mood = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      mbtiType: null == mbtiType
          ? _value.mbtiType
          : mbtiType // ignore: cast_nullable_to_non_nullable
              as String,
      energyLevel: freezed == energyLevel
          ? _value.energyLevel
          : energyLevel // ignore: cast_nullable_to_non_nullable
              as String?,
      mood: freezed == mood
          ? _value.mood
          : mood // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MbtiWidgetDataImplCopyWith<$Res>
    implements $MbtiWidgetDataCopyWith<$Res> {
  factory _$$MbtiWidgetDataImplCopyWith(_$MbtiWidgetDataImpl value,
          $Res Function(_$MbtiWidgetDataImpl) then) =
      __$$MbtiWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String mbtiType, String? energyLevel, String? mood, String? message});
}

/// @nodoc
class __$$MbtiWidgetDataImplCopyWithImpl<$Res>
    extends _$MbtiWidgetDataCopyWithImpl<$Res, _$MbtiWidgetDataImpl>
    implements _$$MbtiWidgetDataImplCopyWith<$Res> {
  __$$MbtiWidgetDataImplCopyWithImpl(
      _$MbtiWidgetDataImpl _value, $Res Function(_$MbtiWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of MbtiWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mbtiType = null,
    Object? energyLevel = freezed,
    Object? mood = freezed,
    Object? message = freezed,
  }) {
    return _then(_$MbtiWidgetDataImpl(
      mbtiType: null == mbtiType
          ? _value.mbtiType
          : mbtiType // ignore: cast_nullable_to_non_nullable
              as String,
      energyLevel: freezed == energyLevel
          ? _value.energyLevel
          : energyLevel // ignore: cast_nullable_to_non_nullable
              as String?,
      mood: freezed == mood
          ? _value.mood
          : mood // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MbtiWidgetDataImpl implements _MbtiWidgetData {
  const _$MbtiWidgetDataImpl(
      {required this.mbtiType, this.energyLevel, this.mood, this.message});

  factory _$MbtiWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$MbtiWidgetDataImplFromJson(json);

  @override
  final String mbtiType;
  @override
  final String? energyLevel;
  @override
  final String? mood;
  @override
  final String? message;

  @override
  String toString() {
    return 'MbtiWidgetData(mbtiType: $mbtiType, energyLevel: $energyLevel, mood: $mood, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MbtiWidgetDataImpl &&
            (identical(other.mbtiType, mbtiType) ||
                other.mbtiType == mbtiType) &&
            (identical(other.energyLevel, energyLevel) ||
                other.energyLevel == energyLevel) &&
            (identical(other.mood, mood) || other.mood == mood) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, mbtiType, energyLevel, mood, message);

  /// Create a copy of MbtiWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MbtiWidgetDataImplCopyWith<_$MbtiWidgetDataImpl> get copyWith =>
      __$$MbtiWidgetDataImplCopyWithImpl<_$MbtiWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MbtiWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _MbtiWidgetData implements MbtiWidgetData {
  const factory _MbtiWidgetData(
      {required final String mbtiType,
      final String? energyLevel,
      final String? mood,
      final String? message}) = _$MbtiWidgetDataImpl;

  factory _MbtiWidgetData.fromJson(Map<String, dynamic> json) =
      _$MbtiWidgetDataImpl.fromJson;

  @override
  String get mbtiType;
  @override
  String? get energyLevel;
  @override
  String? get mood;
  @override
  String? get message;

  /// Create a copy of MbtiWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MbtiWidgetDataImplCopyWith<_$MbtiWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TarotWidgetData _$TarotWidgetDataFromJson(Map<String, dynamic> json) {
  return _TarotWidgetData.fromJson(json);
}

/// @nodoc
mixin _$TarotWidgetData {
  String get cardName => throw _privateConstructorUsedError;
  String? get cardImage => throw _privateConstructorUsedError;
  String? get interpretation => throw _privateConstructorUsedError;

  /// Serializes this TarotWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TarotWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TarotWidgetDataCopyWith<TarotWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TarotWidgetDataCopyWith<$Res> {
  factory $TarotWidgetDataCopyWith(
          TarotWidgetData value, $Res Function(TarotWidgetData) then) =
      _$TarotWidgetDataCopyWithImpl<$Res, TarotWidgetData>;
  @useResult
  $Res call({String cardName, String? cardImage, String? interpretation});
}

/// @nodoc
class _$TarotWidgetDataCopyWithImpl<$Res, $Val extends TarotWidgetData>
    implements $TarotWidgetDataCopyWith<$Res> {
  _$TarotWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TarotWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cardName = null,
    Object? cardImage = freezed,
    Object? interpretation = freezed,
  }) {
    return _then(_value.copyWith(
      cardName: null == cardName
          ? _value.cardName
          : cardName // ignore: cast_nullable_to_non_nullable
              as String,
      cardImage: freezed == cardImage
          ? _value.cardImage
          : cardImage // ignore: cast_nullable_to_non_nullable
              as String?,
      interpretation: freezed == interpretation
          ? _value.interpretation
          : interpretation // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TarotWidgetDataImplCopyWith<$Res>
    implements $TarotWidgetDataCopyWith<$Res> {
  factory _$$TarotWidgetDataImplCopyWith(_$TarotWidgetDataImpl value,
          $Res Function(_$TarotWidgetDataImpl) then) =
      __$$TarotWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String cardName, String? cardImage, String? interpretation});
}

/// @nodoc
class __$$TarotWidgetDataImplCopyWithImpl<$Res>
    extends _$TarotWidgetDataCopyWithImpl<$Res, _$TarotWidgetDataImpl>
    implements _$$TarotWidgetDataImplCopyWith<$Res> {
  __$$TarotWidgetDataImplCopyWithImpl(
      _$TarotWidgetDataImpl _value, $Res Function(_$TarotWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of TarotWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cardName = null,
    Object? cardImage = freezed,
    Object? interpretation = freezed,
  }) {
    return _then(_$TarotWidgetDataImpl(
      cardName: null == cardName
          ? _value.cardName
          : cardName // ignore: cast_nullable_to_non_nullable
              as String,
      cardImage: freezed == cardImage
          ? _value.cardImage
          : cardImage // ignore: cast_nullable_to_non_nullable
              as String?,
      interpretation: freezed == interpretation
          ? _value.interpretation
          : interpretation // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TarotWidgetDataImpl implements _TarotWidgetData {
  const _$TarotWidgetDataImpl(
      {required this.cardName, this.cardImage, this.interpretation});

  factory _$TarotWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$TarotWidgetDataImplFromJson(json);

  @override
  final String cardName;
  @override
  final String? cardImage;
  @override
  final String? interpretation;

  @override
  String toString() {
    return 'TarotWidgetData(cardName: $cardName, cardImage: $cardImage, interpretation: $interpretation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TarotWidgetDataImpl &&
            (identical(other.cardName, cardName) ||
                other.cardName == cardName) &&
            (identical(other.cardImage, cardImage) ||
                other.cardImage == cardImage) &&
            (identical(other.interpretation, interpretation) ||
                other.interpretation == interpretation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, cardName, cardImage, interpretation);

  /// Create a copy of TarotWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TarotWidgetDataImplCopyWith<_$TarotWidgetDataImpl> get copyWith =>
      __$$TarotWidgetDataImplCopyWithImpl<_$TarotWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TarotWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _TarotWidgetData implements TarotWidgetData {
  const factory _TarotWidgetData(
      {required final String cardName,
      final String? cardImage,
      final String? interpretation}) = _$TarotWidgetDataImpl;

  factory _TarotWidgetData.fromJson(Map<String, dynamic> json) =
      _$TarotWidgetDataImpl.fromJson;

  @override
  String get cardName;
  @override
  String? get cardImage;
  @override
  String? get interpretation;

  /// Create a copy of TarotWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TarotWidgetDataImplCopyWith<_$TarotWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BiorhythmWidgetData _$BiorhythmWidgetDataFromJson(Map<String, dynamic> json) {
  return _BiorhythmWidgetData.fromJson(json);
}

/// @nodoc
mixin _$BiorhythmWidgetData {
  String get physical => throw _privateConstructorUsedError;
  String get emotional => throw _privateConstructorUsedError;
  String get intellectual => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this BiorhythmWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of BiorhythmWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BiorhythmWidgetDataCopyWith<BiorhythmWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BiorhythmWidgetDataCopyWith<$Res> {
  factory $BiorhythmWidgetDataCopyWith(
          BiorhythmWidgetData value, $Res Function(BiorhythmWidgetData) then) =
      _$BiorhythmWidgetDataCopyWithImpl<$Res, BiorhythmWidgetData>;
  @useResult
  $Res call(
      {String physical,
      String emotional,
      String intellectual,
      String? message});
}

/// @nodoc
class _$BiorhythmWidgetDataCopyWithImpl<$Res, $Val extends BiorhythmWidgetData>
    implements $BiorhythmWidgetDataCopyWith<$Res> {
  _$BiorhythmWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BiorhythmWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? physical = null,
    Object? emotional = null,
    Object? intellectual = null,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      physical: null == physical
          ? _value.physical
          : physical // ignore: cast_nullable_to_non_nullable
              as String,
      emotional: null == emotional
          ? _value.emotional
          : emotional // ignore: cast_nullable_to_non_nullable
              as String,
      intellectual: null == intellectual
          ? _value.intellectual
          : intellectual // ignore: cast_nullable_to_non_nullable
              as String,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BiorhythmWidgetDataImplCopyWith<$Res>
    implements $BiorhythmWidgetDataCopyWith<$Res> {
  factory _$$BiorhythmWidgetDataImplCopyWith(_$BiorhythmWidgetDataImpl value,
          $Res Function(_$BiorhythmWidgetDataImpl) then) =
      __$$BiorhythmWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String physical,
      String emotional,
      String intellectual,
      String? message});
}

/// @nodoc
class __$$BiorhythmWidgetDataImplCopyWithImpl<$Res>
    extends _$BiorhythmWidgetDataCopyWithImpl<$Res, _$BiorhythmWidgetDataImpl>
    implements _$$BiorhythmWidgetDataImplCopyWith<$Res> {
  __$$BiorhythmWidgetDataImplCopyWithImpl(_$BiorhythmWidgetDataImpl _value,
      $Res Function(_$BiorhythmWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of BiorhythmWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? physical = null,
    Object? emotional = null,
    Object? intellectual = null,
    Object? message = freezed,
  }) {
    return _then(_$BiorhythmWidgetDataImpl(
      physical: null == physical
          ? _value.physical
          : physical // ignore: cast_nullable_to_non_nullable
              as String,
      emotional: null == emotional
          ? _value.emotional
          : emotional // ignore: cast_nullable_to_non_nullable
              as String,
      intellectual: null == intellectual
          ? _value.intellectual
          : intellectual // ignore: cast_nullable_to_non_nullable
              as String,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BiorhythmWidgetDataImpl implements _BiorhythmWidgetData {
  const _$BiorhythmWidgetDataImpl(
      {required this.physical,
      required this.emotional,
      required this.intellectual,
      this.message});

  factory _$BiorhythmWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$BiorhythmWidgetDataImplFromJson(json);

  @override
  final String physical;
  @override
  final String emotional;
  @override
  final String intellectual;
  @override
  final String? message;

  @override
  String toString() {
    return 'BiorhythmWidgetData(physical: $physical, emotional: $emotional, intellectual: $intellectual, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BiorhythmWidgetDataImpl &&
            (identical(other.physical, physical) ||
                other.physical == physical) &&
            (identical(other.emotional, emotional) ||
                other.emotional == emotional) &&
            (identical(other.intellectual, intellectual) ||
                other.intellectual == intellectual) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, physical, emotional, intellectual, message);

  /// Create a copy of BiorhythmWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BiorhythmWidgetDataImplCopyWith<_$BiorhythmWidgetDataImpl> get copyWith =>
      __$$BiorhythmWidgetDataImplCopyWithImpl<_$BiorhythmWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BiorhythmWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _BiorhythmWidgetData implements BiorhythmWidgetData {
  const factory _BiorhythmWidgetData(
      {required final String physical,
      required final String emotional,
      required final String intellectual,
      final String? message}) = _$BiorhythmWidgetDataImpl;

  factory _BiorhythmWidgetData.fromJson(Map<String, dynamic> json) =
      _$BiorhythmWidgetDataImpl.fromJson;

  @override
  String get physical;
  @override
  String get emotional;
  @override
  String get intellectual;
  @override
  String? get message;

  /// Create a copy of BiorhythmWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BiorhythmWidgetDataImplCopyWith<_$BiorhythmWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CompatibilityWidgetData _$CompatibilityWidgetDataFromJson(
    Map<String, dynamic> json) {
  return _CompatibilityWidgetData.fromJson(json);
}

/// @nodoc
mixin _$CompatibilityWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get partnerName => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this CompatibilityWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CompatibilityWidgetDataCopyWith<CompatibilityWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CompatibilityWidgetDataCopyWith<$Res> {
  factory $CompatibilityWidgetDataCopyWith(CompatibilityWidgetData value,
          $Res Function(CompatibilityWidgetData) then) =
      _$CompatibilityWidgetDataCopyWithImpl<$Res, CompatibilityWidgetData>;
  @useResult
  $Res call({String score, String? partnerName, String? message});
}

/// @nodoc
class _$CompatibilityWidgetDataCopyWithImpl<$Res,
        $Val extends CompatibilityWidgetData>
    implements $CompatibilityWidgetDataCopyWith<$Res> {
  _$CompatibilityWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? partnerName = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      partnerName: freezed == partnerName
          ? _value.partnerName
          : partnerName // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CompatibilityWidgetDataImplCopyWith<$Res>
    implements $CompatibilityWidgetDataCopyWith<$Res> {
  factory _$$CompatibilityWidgetDataImplCopyWith(
          _$CompatibilityWidgetDataImpl value,
          $Res Function(_$CompatibilityWidgetDataImpl) then) =
      __$$CompatibilityWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? partnerName, String? message});
}

/// @nodoc
class __$$CompatibilityWidgetDataImplCopyWithImpl<$Res>
    extends _$CompatibilityWidgetDataCopyWithImpl<$Res,
        _$CompatibilityWidgetDataImpl>
    implements _$$CompatibilityWidgetDataImplCopyWith<$Res> {
  __$$CompatibilityWidgetDataImplCopyWithImpl(
      _$CompatibilityWidgetDataImpl _value,
      $Res Function(_$CompatibilityWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of CompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? partnerName = freezed,
    Object? message = freezed,
  }) {
    return _then(_$CompatibilityWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      partnerName: freezed == partnerName
          ? _value.partnerName
          : partnerName // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CompatibilityWidgetDataImpl implements _CompatibilityWidgetData {
  const _$CompatibilityWidgetDataImpl(
      {required this.score, this.partnerName, this.message});

  factory _$CompatibilityWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompatibilityWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? partnerName;
  @override
  final String? message;

  @override
  String toString() {
    return 'CompatibilityWidgetData(score: $score, partnerName: $partnerName, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CompatibilityWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.partnerName, partnerName) ||
                other.partnerName == partnerName) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, partnerName, message);

  /// Create a copy of CompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CompatibilityWidgetDataImplCopyWith<_$CompatibilityWidgetDataImpl>
      get copyWith => __$$CompatibilityWidgetDataImplCopyWithImpl<
          _$CompatibilityWidgetDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CompatibilityWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _CompatibilityWidgetData implements CompatibilityWidgetData {
  const factory _CompatibilityWidgetData(
      {required final String score,
      final String? partnerName,
      final String? message}) = _$CompatibilityWidgetDataImpl;

  factory _CompatibilityWidgetData.fromJson(Map<String, dynamic> json) =
      _$CompatibilityWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get partnerName;
  @override
  String? get message;

  /// Create a copy of CompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CompatibilityWidgetDataImplCopyWith<_$CompatibilityWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

HealthWidgetData _$HealthWidgetDataFromJson(Map<String, dynamic> json) {
  return _HealthWidgetData.fromJson(json);
}

/// @nodoc
mixin _$HealthWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get warningArea => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this HealthWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of HealthWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HealthWidgetDataCopyWith<HealthWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HealthWidgetDataCopyWith<$Res> {
  factory $HealthWidgetDataCopyWith(
          HealthWidgetData value, $Res Function(HealthWidgetData) then) =
      _$HealthWidgetDataCopyWithImpl<$Res, HealthWidgetData>;
  @useResult
  $Res call({String score, String? warningArea, String? message});
}

/// @nodoc
class _$HealthWidgetDataCopyWithImpl<$Res, $Val extends HealthWidgetData>
    implements $HealthWidgetDataCopyWith<$Res> {
  _$HealthWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HealthWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? warningArea = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      warningArea: freezed == warningArea
          ? _value.warningArea
          : warningArea // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HealthWidgetDataImplCopyWith<$Res>
    implements $HealthWidgetDataCopyWith<$Res> {
  factory _$$HealthWidgetDataImplCopyWith(_$HealthWidgetDataImpl value,
          $Res Function(_$HealthWidgetDataImpl) then) =
      __$$HealthWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? warningArea, String? message});
}

/// @nodoc
class __$$HealthWidgetDataImplCopyWithImpl<$Res>
    extends _$HealthWidgetDataCopyWithImpl<$Res, _$HealthWidgetDataImpl>
    implements _$$HealthWidgetDataImplCopyWith<$Res> {
  __$$HealthWidgetDataImplCopyWithImpl(_$HealthWidgetDataImpl _value,
      $Res Function(_$HealthWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of HealthWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? warningArea = freezed,
    Object? message = freezed,
  }) {
    return _then(_$HealthWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      warningArea: freezed == warningArea
          ? _value.warningArea
          : warningArea // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$HealthWidgetDataImpl implements _HealthWidgetData {
  const _$HealthWidgetDataImpl(
      {required this.score, this.warningArea, this.message});

  factory _$HealthWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$HealthWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? warningArea;
  @override
  final String? message;

  @override
  String toString() {
    return 'HealthWidgetData(score: $score, warningArea: $warningArea, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HealthWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.warningArea, warningArea) ||
                other.warningArea == warningArea) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, warningArea, message);

  /// Create a copy of HealthWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HealthWidgetDataImplCopyWith<_$HealthWidgetDataImpl> get copyWith =>
      __$$HealthWidgetDataImplCopyWithImpl<_$HealthWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$HealthWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _HealthWidgetData implements HealthWidgetData {
  const factory _HealthWidgetData(
      {required final String score,
      final String? warningArea,
      final String? message}) = _$HealthWidgetDataImpl;

  factory _HealthWidgetData.fromJson(Map<String, dynamic> json) =
      _$HealthWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get warningArea;
  @override
  String? get message;

  /// Create a copy of HealthWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HealthWidgetDataImplCopyWith<_$HealthWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DreamWidgetData _$DreamWidgetDataFromJson(Map<String, dynamic> json) {
  return _DreamWidgetData.fromJson(json);
}

/// @nodoc
mixin _$DreamWidgetData {
  String? get symbol => throw _privateConstructorUsedError;
  String? get meaning => throw _privateConstructorUsedError;

  /// Serializes this DreamWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DreamWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DreamWidgetDataCopyWith<DreamWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DreamWidgetDataCopyWith<$Res> {
  factory $DreamWidgetDataCopyWith(
          DreamWidgetData value, $Res Function(DreamWidgetData) then) =
      _$DreamWidgetDataCopyWithImpl<$Res, DreamWidgetData>;
  @useResult
  $Res call({String? symbol, String? meaning});
}

/// @nodoc
class _$DreamWidgetDataCopyWithImpl<$Res, $Val extends DreamWidgetData>
    implements $DreamWidgetDataCopyWith<$Res> {
  _$DreamWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DreamWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbol = freezed,
    Object? meaning = freezed,
  }) {
    return _then(_value.copyWith(
      symbol: freezed == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String?,
      meaning: freezed == meaning
          ? _value.meaning
          : meaning // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DreamWidgetDataImplCopyWith<$Res>
    implements $DreamWidgetDataCopyWith<$Res> {
  factory _$$DreamWidgetDataImplCopyWith(_$DreamWidgetDataImpl value,
          $Res Function(_$DreamWidgetDataImpl) then) =
      __$$DreamWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? symbol, String? meaning});
}

/// @nodoc
class __$$DreamWidgetDataImplCopyWithImpl<$Res>
    extends _$DreamWidgetDataCopyWithImpl<$Res, _$DreamWidgetDataImpl>
    implements _$$DreamWidgetDataImplCopyWith<$Res> {
  __$$DreamWidgetDataImplCopyWithImpl(
      _$DreamWidgetDataImpl _value, $Res Function(_$DreamWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of DreamWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbol = freezed,
    Object? meaning = freezed,
  }) {
    return _then(_$DreamWidgetDataImpl(
      symbol: freezed == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String?,
      meaning: freezed == meaning
          ? _value.meaning
          : meaning // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DreamWidgetDataImpl implements _DreamWidgetData {
  const _$DreamWidgetDataImpl({this.symbol, this.meaning});

  factory _$DreamWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$DreamWidgetDataImplFromJson(json);

  @override
  final String? symbol;
  @override
  final String? meaning;

  @override
  String toString() {
    return 'DreamWidgetData(symbol: $symbol, meaning: $meaning)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DreamWidgetDataImpl &&
            (identical(other.symbol, symbol) || other.symbol == symbol) &&
            (identical(other.meaning, meaning) || other.meaning == meaning));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, symbol, meaning);

  /// Create a copy of DreamWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DreamWidgetDataImplCopyWith<_$DreamWidgetDataImpl> get copyWith =>
      __$$DreamWidgetDataImplCopyWithImpl<_$DreamWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DreamWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _DreamWidgetData implements DreamWidgetData {
  const factory _DreamWidgetData(
      {final String? symbol, final String? meaning}) = _$DreamWidgetDataImpl;

  factory _DreamWidgetData.fromJson(Map<String, dynamic> json) =
      _$DreamWidgetDataImpl.fromJson;

  @override
  String? get symbol;
  @override
  String? get meaning;

  /// Create a copy of DreamWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DreamWidgetDataImplCopyWith<_$DreamWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LuckyItemsWidgetData _$LuckyItemsWidgetDataFromJson(Map<String, dynamic> json) {
  return _LuckyItemsWidgetData.fromJson(json);
}

/// @nodoc
mixin _$LuckyItemsWidgetData {
  List<String> get items => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this LuckyItemsWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of LuckyItemsWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LuckyItemsWidgetDataCopyWith<LuckyItemsWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LuckyItemsWidgetDataCopyWith<$Res> {
  factory $LuckyItemsWidgetDataCopyWith(LuckyItemsWidgetData value,
          $Res Function(LuckyItemsWidgetData) then) =
      _$LuckyItemsWidgetDataCopyWithImpl<$Res, LuckyItemsWidgetData>;
  @useResult
  $Res call({List<String> items, String? message});
}

/// @nodoc
class _$LuckyItemsWidgetDataCopyWithImpl<$Res,
        $Val extends LuckyItemsWidgetData>
    implements $LuckyItemsWidgetDataCopyWith<$Res> {
  _$LuckyItemsWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LuckyItemsWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = null,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      items: null == items
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as List<String>,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LuckyItemsWidgetDataImplCopyWith<$Res>
    implements $LuckyItemsWidgetDataCopyWith<$Res> {
  factory _$$LuckyItemsWidgetDataImplCopyWith(_$LuckyItemsWidgetDataImpl value,
          $Res Function(_$LuckyItemsWidgetDataImpl) then) =
      __$$LuckyItemsWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String> items, String? message});
}

/// @nodoc
class __$$LuckyItemsWidgetDataImplCopyWithImpl<$Res>
    extends _$LuckyItemsWidgetDataCopyWithImpl<$Res, _$LuckyItemsWidgetDataImpl>
    implements _$$LuckyItemsWidgetDataImplCopyWith<$Res> {
  __$$LuckyItemsWidgetDataImplCopyWithImpl(_$LuckyItemsWidgetDataImpl _value,
      $Res Function(_$LuckyItemsWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of LuckyItemsWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = null,
    Object? message = freezed,
  }) {
    return _then(_$LuckyItemsWidgetDataImpl(
      items: null == items
          ? _value._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<String>,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LuckyItemsWidgetDataImpl implements _LuckyItemsWidgetData {
  const _$LuckyItemsWidgetDataImpl(
      {final List<String> items = const [], this.message})
      : _items = items;

  factory _$LuckyItemsWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$LuckyItemsWidgetDataImplFromJson(json);

  final List<String> _items;
  @override
  @JsonKey()
  List<String> get items {
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_items);
  }

  @override
  final String? message;

  @override
  String toString() {
    return 'LuckyItemsWidgetData(items: $items, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LuckyItemsWidgetDataImpl &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_items), message);

  /// Create a copy of LuckyItemsWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LuckyItemsWidgetDataImplCopyWith<_$LuckyItemsWidgetDataImpl>
      get copyWith =>
          __$$LuckyItemsWidgetDataImplCopyWithImpl<_$LuckyItemsWidgetDataImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LuckyItemsWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _LuckyItemsWidgetData implements LuckyItemsWidgetData {
  const factory _LuckyItemsWidgetData(
      {final List<String> items,
      final String? message}) = _$LuckyItemsWidgetDataImpl;

  factory _LuckyItemsWidgetData.fromJson(Map<String, dynamic> json) =
      _$LuckyItemsWidgetDataImpl.fromJson;

  @override
  List<String> get items;
  @override
  String? get message;

  /// Create a copy of LuckyItemsWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LuckyItemsWidgetDataImplCopyWith<_$LuckyItemsWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TraditionalSajuWidgetData _$TraditionalSajuWidgetDataFromJson(
    Map<String, dynamic> json) {
  return _TraditionalSajuWidgetData.fromJson(json);
}

/// @nodoc
mixin _$TraditionalSajuWidgetData {
  String? get summary => throw _privateConstructorUsedError;
  String? get todayFortune => throw _privateConstructorUsedError;

  /// Serializes this TraditionalSajuWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TraditionalSajuWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TraditionalSajuWidgetDataCopyWith<TraditionalSajuWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TraditionalSajuWidgetDataCopyWith<$Res> {
  factory $TraditionalSajuWidgetDataCopyWith(TraditionalSajuWidgetData value,
          $Res Function(TraditionalSajuWidgetData) then) =
      _$TraditionalSajuWidgetDataCopyWithImpl<$Res, TraditionalSajuWidgetData>;
  @useResult
  $Res call({String? summary, String? todayFortune});
}

/// @nodoc
class _$TraditionalSajuWidgetDataCopyWithImpl<$Res,
        $Val extends TraditionalSajuWidgetData>
    implements $TraditionalSajuWidgetDataCopyWith<$Res> {
  _$TraditionalSajuWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TraditionalSajuWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? summary = freezed,
    Object? todayFortune = freezed,
  }) {
    return _then(_value.copyWith(
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      todayFortune: freezed == todayFortune
          ? _value.todayFortune
          : todayFortune // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TraditionalSajuWidgetDataImplCopyWith<$Res>
    implements $TraditionalSajuWidgetDataCopyWith<$Res> {
  factory _$$TraditionalSajuWidgetDataImplCopyWith(
          _$TraditionalSajuWidgetDataImpl value,
          $Res Function(_$TraditionalSajuWidgetDataImpl) then) =
      __$$TraditionalSajuWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? summary, String? todayFortune});
}

/// @nodoc
class __$$TraditionalSajuWidgetDataImplCopyWithImpl<$Res>
    extends _$TraditionalSajuWidgetDataCopyWithImpl<$Res,
        _$TraditionalSajuWidgetDataImpl>
    implements _$$TraditionalSajuWidgetDataImplCopyWith<$Res> {
  __$$TraditionalSajuWidgetDataImplCopyWithImpl(
      _$TraditionalSajuWidgetDataImpl _value,
      $Res Function(_$TraditionalSajuWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of TraditionalSajuWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? summary = freezed,
    Object? todayFortune = freezed,
  }) {
    return _then(_$TraditionalSajuWidgetDataImpl(
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      todayFortune: freezed == todayFortune
          ? _value.todayFortune
          : todayFortune // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TraditionalSajuWidgetDataImpl implements _TraditionalSajuWidgetData {
  const _$TraditionalSajuWidgetDataImpl({this.summary, this.todayFortune});

  factory _$TraditionalSajuWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$TraditionalSajuWidgetDataImplFromJson(json);

  @override
  final String? summary;
  @override
  final String? todayFortune;

  @override
  String toString() {
    return 'TraditionalSajuWidgetData(summary: $summary, todayFortune: $todayFortune)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TraditionalSajuWidgetDataImpl &&
            (identical(other.summary, summary) || other.summary == summary) &&
            (identical(other.todayFortune, todayFortune) ||
                other.todayFortune == todayFortune));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, summary, todayFortune);

  /// Create a copy of TraditionalSajuWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TraditionalSajuWidgetDataImplCopyWith<_$TraditionalSajuWidgetDataImpl>
      get copyWith => __$$TraditionalSajuWidgetDataImplCopyWithImpl<
          _$TraditionalSajuWidgetDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TraditionalSajuWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _TraditionalSajuWidgetData implements TraditionalSajuWidgetData {
  const factory _TraditionalSajuWidgetData(
      {final String? summary,
      final String? todayFortune}) = _$TraditionalSajuWidgetDataImpl;

  factory _TraditionalSajuWidgetData.fromJson(Map<String, dynamic> json) =
      _$TraditionalSajuWidgetDataImpl.fromJson;

  @override
  String? get summary;
  @override
  String? get todayFortune;

  /// Create a copy of TraditionalSajuWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TraditionalSajuWidgetDataImplCopyWith<_$TraditionalSajuWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FaceReadingWidgetData _$FaceReadingWidgetDataFromJson(
    Map<String, dynamic> json) {
  return _FaceReadingWidgetData.fromJson(json);
}

/// @nodoc
mixin _$FaceReadingWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get features => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this FaceReadingWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FaceReadingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FaceReadingWidgetDataCopyWith<FaceReadingWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FaceReadingWidgetDataCopyWith<$Res> {
  factory $FaceReadingWidgetDataCopyWith(FaceReadingWidgetData value,
          $Res Function(FaceReadingWidgetData) then) =
      _$FaceReadingWidgetDataCopyWithImpl<$Res, FaceReadingWidgetData>;
  @useResult
  $Res call({String score, String? features, String? message});
}

/// @nodoc
class _$FaceReadingWidgetDataCopyWithImpl<$Res,
        $Val extends FaceReadingWidgetData>
    implements $FaceReadingWidgetDataCopyWith<$Res> {
  _$FaceReadingWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FaceReadingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? features = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      features: freezed == features
          ? _value.features
          : features // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FaceReadingWidgetDataImplCopyWith<$Res>
    implements $FaceReadingWidgetDataCopyWith<$Res> {
  factory _$$FaceReadingWidgetDataImplCopyWith(
          _$FaceReadingWidgetDataImpl value,
          $Res Function(_$FaceReadingWidgetDataImpl) then) =
      __$$FaceReadingWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? features, String? message});
}

/// @nodoc
class __$$FaceReadingWidgetDataImplCopyWithImpl<$Res>
    extends _$FaceReadingWidgetDataCopyWithImpl<$Res,
        _$FaceReadingWidgetDataImpl>
    implements _$$FaceReadingWidgetDataImplCopyWith<$Res> {
  __$$FaceReadingWidgetDataImplCopyWithImpl(_$FaceReadingWidgetDataImpl _value,
      $Res Function(_$FaceReadingWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of FaceReadingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? features = freezed,
    Object? message = freezed,
  }) {
    return _then(_$FaceReadingWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      features: freezed == features
          ? _value.features
          : features // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FaceReadingWidgetDataImpl implements _FaceReadingWidgetData {
  const _$FaceReadingWidgetDataImpl(
      {required this.score, this.features, this.message});

  factory _$FaceReadingWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$FaceReadingWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? features;
  @override
  final String? message;

  @override
  String toString() {
    return 'FaceReadingWidgetData(score: $score, features: $features, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FaceReadingWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.features, features) ||
                other.features == features) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, features, message);

  /// Create a copy of FaceReadingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FaceReadingWidgetDataImplCopyWith<_$FaceReadingWidgetDataImpl>
      get copyWith => __$$FaceReadingWidgetDataImplCopyWithImpl<
          _$FaceReadingWidgetDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FaceReadingWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _FaceReadingWidgetData implements FaceReadingWidgetData {
  const factory _FaceReadingWidgetData(
      {required final String score,
      final String? features,
      final String? message}) = _$FaceReadingWidgetDataImpl;

  factory _FaceReadingWidgetData.fromJson(Map<String, dynamic> json) =
      _$FaceReadingWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get features;
  @override
  String? get message;

  /// Create a copy of FaceReadingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FaceReadingWidgetDataImplCopyWith<_$FaceReadingWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TalentWidgetData _$TalentWidgetDataFromJson(Map<String, dynamic> json) {
  return _TalentWidgetData.fromJson(json);
}

/// @nodoc
mixin _$TalentWidgetData {
  String? get area => throw _privateConstructorUsedError;
  String? get activity => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this TalentWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TalentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TalentWidgetDataCopyWith<TalentWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TalentWidgetDataCopyWith<$Res> {
  factory $TalentWidgetDataCopyWith(
          TalentWidgetData value, $Res Function(TalentWidgetData) then) =
      _$TalentWidgetDataCopyWithImpl<$Res, TalentWidgetData>;
  @useResult
  $Res call({String? area, String? activity, String? message});
}

/// @nodoc
class _$TalentWidgetDataCopyWithImpl<$Res, $Val extends TalentWidgetData>
    implements $TalentWidgetDataCopyWith<$Res> {
  _$TalentWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TalentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? area = freezed,
    Object? activity = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      area: freezed == area
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as String?,
      activity: freezed == activity
          ? _value.activity
          : activity // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TalentWidgetDataImplCopyWith<$Res>
    implements $TalentWidgetDataCopyWith<$Res> {
  factory _$$TalentWidgetDataImplCopyWith(_$TalentWidgetDataImpl value,
          $Res Function(_$TalentWidgetDataImpl) then) =
      __$$TalentWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? area, String? activity, String? message});
}

/// @nodoc
class __$$TalentWidgetDataImplCopyWithImpl<$Res>
    extends _$TalentWidgetDataCopyWithImpl<$Res, _$TalentWidgetDataImpl>
    implements _$$TalentWidgetDataImplCopyWith<$Res> {
  __$$TalentWidgetDataImplCopyWithImpl(_$TalentWidgetDataImpl _value,
      $Res Function(_$TalentWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of TalentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? area = freezed,
    Object? activity = freezed,
    Object? message = freezed,
  }) {
    return _then(_$TalentWidgetDataImpl(
      area: freezed == area
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as String?,
      activity: freezed == activity
          ? _value.activity
          : activity // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TalentWidgetDataImpl implements _TalentWidgetData {
  const _$TalentWidgetDataImpl({this.area, this.activity, this.message});

  factory _$TalentWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$TalentWidgetDataImplFromJson(json);

  @override
  final String? area;
  @override
  final String? activity;
  @override
  final String? message;

  @override
  String toString() {
    return 'TalentWidgetData(area: $area, activity: $activity, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TalentWidgetDataImpl &&
            (identical(other.area, area) || other.area == area) &&
            (identical(other.activity, activity) ||
                other.activity == activity) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, area, activity, message);

  /// Create a copy of TalentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TalentWidgetDataImplCopyWith<_$TalentWidgetDataImpl> get copyWith =>
      __$$TalentWidgetDataImplCopyWithImpl<_$TalentWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TalentWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _TalentWidgetData implements TalentWidgetData {
  const factory _TalentWidgetData(
      {final String? area,
      final String? activity,
      final String? message}) = _$TalentWidgetDataImpl;

  factory _TalentWidgetData.fromJson(Map<String, dynamic> json) =
      _$TalentWidgetDataImpl.fromJson;

  @override
  String? get area;
  @override
  String? get activity;
  @override
  String? get message;

  /// Create a copy of TalentWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TalentWidgetDataImplCopyWith<_$TalentWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BlindDateWidgetData _$BlindDateWidgetDataFromJson(Map<String, dynamic> json) {
  return _BlindDateWidgetData.fromJson(json);
}

/// @nodoc
mixin _$BlindDateWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get bestDay => throw _privateConstructorUsedError;
  String? get advice => throw _privateConstructorUsedError;

  /// Serializes this BlindDateWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of BlindDateWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BlindDateWidgetDataCopyWith<BlindDateWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlindDateWidgetDataCopyWith<$Res> {
  factory $BlindDateWidgetDataCopyWith(
          BlindDateWidgetData value, $Res Function(BlindDateWidgetData) then) =
      _$BlindDateWidgetDataCopyWithImpl<$Res, BlindDateWidgetData>;
  @useResult
  $Res call({String score, String? bestDay, String? advice});
}

/// @nodoc
class _$BlindDateWidgetDataCopyWithImpl<$Res, $Val extends BlindDateWidgetData>
    implements $BlindDateWidgetDataCopyWith<$Res> {
  _$BlindDateWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BlindDateWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? bestDay = freezed,
    Object? advice = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      bestDay: freezed == bestDay
          ? _value.bestDay
          : bestDay // ignore: cast_nullable_to_non_nullable
              as String?,
      advice: freezed == advice
          ? _value.advice
          : advice // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BlindDateWidgetDataImplCopyWith<$Res>
    implements $BlindDateWidgetDataCopyWith<$Res> {
  factory _$$BlindDateWidgetDataImplCopyWith(_$BlindDateWidgetDataImpl value,
          $Res Function(_$BlindDateWidgetDataImpl) then) =
      __$$BlindDateWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? bestDay, String? advice});
}

/// @nodoc
class __$$BlindDateWidgetDataImplCopyWithImpl<$Res>
    extends _$BlindDateWidgetDataCopyWithImpl<$Res, _$BlindDateWidgetDataImpl>
    implements _$$BlindDateWidgetDataImplCopyWith<$Res> {
  __$$BlindDateWidgetDataImplCopyWithImpl(_$BlindDateWidgetDataImpl _value,
      $Res Function(_$BlindDateWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of BlindDateWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? bestDay = freezed,
    Object? advice = freezed,
  }) {
    return _then(_$BlindDateWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      bestDay: freezed == bestDay
          ? _value.bestDay
          : bestDay // ignore: cast_nullable_to_non_nullable
              as String?,
      advice: freezed == advice
          ? _value.advice
          : advice // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BlindDateWidgetDataImpl implements _BlindDateWidgetData {
  const _$BlindDateWidgetDataImpl(
      {required this.score, this.bestDay, this.advice});

  factory _$BlindDateWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$BlindDateWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? bestDay;
  @override
  final String? advice;

  @override
  String toString() {
    return 'BlindDateWidgetData(score: $score, bestDay: $bestDay, advice: $advice)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlindDateWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.bestDay, bestDay) || other.bestDay == bestDay) &&
            (identical(other.advice, advice) || other.advice == advice));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, bestDay, advice);

  /// Create a copy of BlindDateWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlindDateWidgetDataImplCopyWith<_$BlindDateWidgetDataImpl> get copyWith =>
      __$$BlindDateWidgetDataImplCopyWithImpl<_$BlindDateWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BlindDateWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _BlindDateWidgetData implements BlindDateWidgetData {
  const factory _BlindDateWidgetData(
      {required final String score,
      final String? bestDay,
      final String? advice}) = _$BlindDateWidgetDataImpl;

  factory _BlindDateWidgetData.fromJson(Map<String, dynamic> json) =
      _$BlindDateWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get bestDay;
  @override
  String? get advice;

  /// Create a copy of BlindDateWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlindDateWidgetDataImplCopyWith<_$BlindDateWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ExLoverWidgetData _$ExLoverWidgetDataFromJson(Map<String, dynamic> json) {
  return _ExLoverWidgetData.fromJson(json);
}

/// @nodoc
mixin _$ExLoverWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get possibility => throw _privateConstructorUsedError;
  String? get advice => throw _privateConstructorUsedError;

  /// Serializes this ExLoverWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ExLoverWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ExLoverWidgetDataCopyWith<ExLoverWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExLoverWidgetDataCopyWith<$Res> {
  factory $ExLoverWidgetDataCopyWith(
          ExLoverWidgetData value, $Res Function(ExLoverWidgetData) then) =
      _$ExLoverWidgetDataCopyWithImpl<$Res, ExLoverWidgetData>;
  @useResult
  $Res call({String score, String? possibility, String? advice});
}

/// @nodoc
class _$ExLoverWidgetDataCopyWithImpl<$Res, $Val extends ExLoverWidgetData>
    implements $ExLoverWidgetDataCopyWith<$Res> {
  _$ExLoverWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ExLoverWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? possibility = freezed,
    Object? advice = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      possibility: freezed == possibility
          ? _value.possibility
          : possibility // ignore: cast_nullable_to_non_nullable
              as String?,
      advice: freezed == advice
          ? _value.advice
          : advice // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExLoverWidgetDataImplCopyWith<$Res>
    implements $ExLoverWidgetDataCopyWith<$Res> {
  factory _$$ExLoverWidgetDataImplCopyWith(_$ExLoverWidgetDataImpl value,
          $Res Function(_$ExLoverWidgetDataImpl) then) =
      __$$ExLoverWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? possibility, String? advice});
}

/// @nodoc
class __$$ExLoverWidgetDataImplCopyWithImpl<$Res>
    extends _$ExLoverWidgetDataCopyWithImpl<$Res, _$ExLoverWidgetDataImpl>
    implements _$$ExLoverWidgetDataImplCopyWith<$Res> {
  __$$ExLoverWidgetDataImplCopyWithImpl(_$ExLoverWidgetDataImpl _value,
      $Res Function(_$ExLoverWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExLoverWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? possibility = freezed,
    Object? advice = freezed,
  }) {
    return _then(_$ExLoverWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      possibility: freezed == possibility
          ? _value.possibility
          : possibility // ignore: cast_nullable_to_non_nullable
              as String?,
      advice: freezed == advice
          ? _value.advice
          : advice // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExLoverWidgetDataImpl implements _ExLoverWidgetData {
  const _$ExLoverWidgetDataImpl(
      {required this.score, this.possibility, this.advice});

  factory _$ExLoverWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExLoverWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? possibility;
  @override
  final String? advice;

  @override
  String toString() {
    return 'ExLoverWidgetData(score: $score, possibility: $possibility, advice: $advice)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExLoverWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.possibility, possibility) ||
                other.possibility == possibility) &&
            (identical(other.advice, advice) || other.advice == advice));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, possibility, advice);

  /// Create a copy of ExLoverWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExLoverWidgetDataImplCopyWith<_$ExLoverWidgetDataImpl> get copyWith =>
      __$$ExLoverWidgetDataImplCopyWithImpl<_$ExLoverWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExLoverWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _ExLoverWidgetData implements ExLoverWidgetData {
  const factory _ExLoverWidgetData(
      {required final String score,
      final String? possibility,
      final String? advice}) = _$ExLoverWidgetDataImpl;

  factory _ExLoverWidgetData.fromJson(Map<String, dynamic> json) =
      _$ExLoverWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get possibility;
  @override
  String? get advice;

  /// Create a copy of ExLoverWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExLoverWidgetDataImplCopyWith<_$ExLoverWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MovingWidgetData _$MovingWidgetDataFromJson(Map<String, dynamic> json) {
  return _MovingWidgetData.fromJson(json);
}

/// @nodoc
mixin _$MovingWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get bestDirection => throw _privateConstructorUsedError;
  String? get bestDate => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this MovingWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MovingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MovingWidgetDataCopyWith<MovingWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MovingWidgetDataCopyWith<$Res> {
  factory $MovingWidgetDataCopyWith(
          MovingWidgetData value, $Res Function(MovingWidgetData) then) =
      _$MovingWidgetDataCopyWithImpl<$Res, MovingWidgetData>;
  @useResult
  $Res call(
      {String score, String? bestDirection, String? bestDate, String? message});
}

/// @nodoc
class _$MovingWidgetDataCopyWithImpl<$Res, $Val extends MovingWidgetData>
    implements $MovingWidgetDataCopyWith<$Res> {
  _$MovingWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MovingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? bestDirection = freezed,
    Object? bestDate = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      bestDirection: freezed == bestDirection
          ? _value.bestDirection
          : bestDirection // ignore: cast_nullable_to_non_nullable
              as String?,
      bestDate: freezed == bestDate
          ? _value.bestDate
          : bestDate // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MovingWidgetDataImplCopyWith<$Res>
    implements $MovingWidgetDataCopyWith<$Res> {
  factory _$$MovingWidgetDataImplCopyWith(_$MovingWidgetDataImpl value,
          $Res Function(_$MovingWidgetDataImpl) then) =
      __$$MovingWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String score, String? bestDirection, String? bestDate, String? message});
}

/// @nodoc
class __$$MovingWidgetDataImplCopyWithImpl<$Res>
    extends _$MovingWidgetDataCopyWithImpl<$Res, _$MovingWidgetDataImpl>
    implements _$$MovingWidgetDataImplCopyWith<$Res> {
  __$$MovingWidgetDataImplCopyWithImpl(_$MovingWidgetDataImpl _value,
      $Res Function(_$MovingWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of MovingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? bestDirection = freezed,
    Object? bestDate = freezed,
    Object? message = freezed,
  }) {
    return _then(_$MovingWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      bestDirection: freezed == bestDirection
          ? _value.bestDirection
          : bestDirection // ignore: cast_nullable_to_non_nullable
              as String?,
      bestDate: freezed == bestDate
          ? _value.bestDate
          : bestDate // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MovingWidgetDataImpl implements _MovingWidgetData {
  const _$MovingWidgetDataImpl(
      {required this.score, this.bestDirection, this.bestDate, this.message});

  factory _$MovingWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$MovingWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? bestDirection;
  @override
  final String? bestDate;
  @override
  final String? message;

  @override
  String toString() {
    return 'MovingWidgetData(score: $score, bestDirection: $bestDirection, bestDate: $bestDate, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MovingWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.bestDirection, bestDirection) ||
                other.bestDirection == bestDirection) &&
            (identical(other.bestDate, bestDate) ||
                other.bestDate == bestDate) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, score, bestDirection, bestDate, message);

  /// Create a copy of MovingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MovingWidgetDataImplCopyWith<_$MovingWidgetDataImpl> get copyWith =>
      __$$MovingWidgetDataImplCopyWithImpl<_$MovingWidgetDataImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MovingWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _MovingWidgetData implements MovingWidgetData {
  const factory _MovingWidgetData(
      {required final String score,
      final String? bestDirection,
      final String? bestDate,
      final String? message}) = _$MovingWidgetDataImpl;

  factory _MovingWidgetData.fromJson(Map<String, dynamic> json) =
      _$MovingWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get bestDirection;
  @override
  String? get bestDate;
  @override
  String? get message;

  /// Create a copy of MovingWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MovingWidgetDataImplCopyWith<_$MovingWidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PetCompatibilityWidgetData _$PetCompatibilityWidgetDataFromJson(
    Map<String, dynamic> json) {
  return _PetCompatibilityWidgetData.fromJson(json);
}

/// @nodoc
mixin _$PetCompatibilityWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get petType => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this PetCompatibilityWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PetCompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PetCompatibilityWidgetDataCopyWith<PetCompatibilityWidgetData>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PetCompatibilityWidgetDataCopyWith<$Res> {
  factory $PetCompatibilityWidgetDataCopyWith(PetCompatibilityWidgetData value,
          $Res Function(PetCompatibilityWidgetData) then) =
      _$PetCompatibilityWidgetDataCopyWithImpl<$Res,
          PetCompatibilityWidgetData>;
  @useResult
  $Res call({String score, String? petType, String? message});
}

/// @nodoc
class _$PetCompatibilityWidgetDataCopyWithImpl<$Res,
        $Val extends PetCompatibilityWidgetData>
    implements $PetCompatibilityWidgetDataCopyWith<$Res> {
  _$PetCompatibilityWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PetCompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? petType = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      petType: freezed == petType
          ? _value.petType
          : petType // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PetCompatibilityWidgetDataImplCopyWith<$Res>
    implements $PetCompatibilityWidgetDataCopyWith<$Res> {
  factory _$$PetCompatibilityWidgetDataImplCopyWith(
          _$PetCompatibilityWidgetDataImpl value,
          $Res Function(_$PetCompatibilityWidgetDataImpl) then) =
      __$$PetCompatibilityWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? petType, String? message});
}

/// @nodoc
class __$$PetCompatibilityWidgetDataImplCopyWithImpl<$Res>
    extends _$PetCompatibilityWidgetDataCopyWithImpl<$Res,
        _$PetCompatibilityWidgetDataImpl>
    implements _$$PetCompatibilityWidgetDataImplCopyWith<$Res> {
  __$$PetCompatibilityWidgetDataImplCopyWithImpl(
      _$PetCompatibilityWidgetDataImpl _value,
      $Res Function(_$PetCompatibilityWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of PetCompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? petType = freezed,
    Object? message = freezed,
  }) {
    return _then(_$PetCompatibilityWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      petType: freezed == petType
          ? _value.petType
          : petType // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PetCompatibilityWidgetDataImpl implements _PetCompatibilityWidgetData {
  const _$PetCompatibilityWidgetDataImpl(
      {required this.score, this.petType, this.message});

  factory _$PetCompatibilityWidgetDataImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$PetCompatibilityWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? petType;
  @override
  final String? message;

  @override
  String toString() {
    return 'PetCompatibilityWidgetData(score: $score, petType: $petType, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PetCompatibilityWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.petType, petType) || other.petType == petType) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, petType, message);

  /// Create a copy of PetCompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PetCompatibilityWidgetDataImplCopyWith<_$PetCompatibilityWidgetDataImpl>
      get copyWith => __$$PetCompatibilityWidgetDataImplCopyWithImpl<
          _$PetCompatibilityWidgetDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PetCompatibilityWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _PetCompatibilityWidgetData
    implements PetCompatibilityWidgetData {
  const factory _PetCompatibilityWidgetData(
      {required final String score,
      final String? petType,
      final String? message}) = _$PetCompatibilityWidgetDataImpl;

  factory _PetCompatibilityWidgetData.fromJson(Map<String, dynamic> json) =
      _$PetCompatibilityWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get petType;
  @override
  String? get message;

  /// Create a copy of PetCompatibilityWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PetCompatibilityWidgetDataImplCopyWith<_$PetCompatibilityWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

FamilyHarmonyWidgetData _$FamilyHarmonyWidgetDataFromJson(
    Map<String, dynamic> json) {
  return _FamilyHarmonyWidgetData.fromJson(json);
}

/// @nodoc
mixin _$FamilyHarmonyWidgetData {
  String get score => throw _privateConstructorUsedError;
  String? get advice => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this FamilyHarmonyWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FamilyHarmonyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FamilyHarmonyWidgetDataCopyWith<FamilyHarmonyWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FamilyHarmonyWidgetDataCopyWith<$Res> {
  factory $FamilyHarmonyWidgetDataCopyWith(FamilyHarmonyWidgetData value,
          $Res Function(FamilyHarmonyWidgetData) then) =
      _$FamilyHarmonyWidgetDataCopyWithImpl<$Res, FamilyHarmonyWidgetData>;
  @useResult
  $Res call({String score, String? advice, String? message});
}

/// @nodoc
class _$FamilyHarmonyWidgetDataCopyWithImpl<$Res,
        $Val extends FamilyHarmonyWidgetData>
    implements $FamilyHarmonyWidgetDataCopyWith<$Res> {
  _$FamilyHarmonyWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FamilyHarmonyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? advice = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      advice: freezed == advice
          ? _value.advice
          : advice // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FamilyHarmonyWidgetDataImplCopyWith<$Res>
    implements $FamilyHarmonyWidgetDataCopyWith<$Res> {
  factory _$$FamilyHarmonyWidgetDataImplCopyWith(
          _$FamilyHarmonyWidgetDataImpl value,
          $Res Function(_$FamilyHarmonyWidgetDataImpl) then) =
      __$$FamilyHarmonyWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String score, String? advice, String? message});
}

/// @nodoc
class __$$FamilyHarmonyWidgetDataImplCopyWithImpl<$Res>
    extends _$FamilyHarmonyWidgetDataCopyWithImpl<$Res,
        _$FamilyHarmonyWidgetDataImpl>
    implements _$$FamilyHarmonyWidgetDataImplCopyWith<$Res> {
  __$$FamilyHarmonyWidgetDataImplCopyWithImpl(
      _$FamilyHarmonyWidgetDataImpl _value,
      $Res Function(_$FamilyHarmonyWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of FamilyHarmonyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? score = null,
    Object? advice = freezed,
    Object? message = freezed,
  }) {
    return _then(_$FamilyHarmonyWidgetDataImpl(
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      advice: freezed == advice
          ? _value.advice
          : advice // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FamilyHarmonyWidgetDataImpl implements _FamilyHarmonyWidgetData {
  const _$FamilyHarmonyWidgetDataImpl(
      {required this.score, this.advice, this.message});

  factory _$FamilyHarmonyWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$FamilyHarmonyWidgetDataImplFromJson(json);

  @override
  final String score;
  @override
  final String? advice;
  @override
  final String? message;

  @override
  String toString() {
    return 'FamilyHarmonyWidgetData(score: $score, advice: $advice, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FamilyHarmonyWidgetDataImpl &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.advice, advice) || other.advice == advice) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, score, advice, message);

  /// Create a copy of FamilyHarmonyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FamilyHarmonyWidgetDataImplCopyWith<_$FamilyHarmonyWidgetDataImpl>
      get copyWith => __$$FamilyHarmonyWidgetDataImplCopyWithImpl<
          _$FamilyHarmonyWidgetDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FamilyHarmonyWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _FamilyHarmonyWidgetData implements FamilyHarmonyWidgetData {
  const factory _FamilyHarmonyWidgetData(
      {required final String score,
      final String? advice,
      final String? message}) = _$FamilyHarmonyWidgetDataImpl;

  factory _FamilyHarmonyWidgetData.fromJson(Map<String, dynamic> json) =
      _$FamilyHarmonyWidgetDataImpl.fromJson;

  @override
  String get score;
  @override
  String? get advice;
  @override
  String? get message;

  /// Create a copy of FamilyHarmonyWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FamilyHarmonyWidgetDataImplCopyWith<_$FamilyHarmonyWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TimeFortuneWidgetData _$TimeFortuneWidgetDataFromJson(
    Map<String, dynamic> json) {
  return _TimeFortuneWidgetData.fromJson(json);
}

/// @nodoc
mixin _$TimeFortuneWidgetData {
  String get currentPeriod => throw _privateConstructorUsedError;
  String get score => throw _privateConstructorUsedError;
  String? get nextPeriod => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;

  /// Serializes this TimeFortuneWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TimeFortuneWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TimeFortuneWidgetDataCopyWith<TimeFortuneWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TimeFortuneWidgetDataCopyWith<$Res> {
  factory $TimeFortuneWidgetDataCopyWith(TimeFortuneWidgetData value,
          $Res Function(TimeFortuneWidgetData) then) =
      _$TimeFortuneWidgetDataCopyWithImpl<$Res, TimeFortuneWidgetData>;
  @useResult
  $Res call(
      {String currentPeriod,
      String score,
      String? nextPeriod,
      String? message});
}

/// @nodoc
class _$TimeFortuneWidgetDataCopyWithImpl<$Res,
        $Val extends TimeFortuneWidgetData>
    implements $TimeFortuneWidgetDataCopyWith<$Res> {
  _$TimeFortuneWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TimeFortuneWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPeriod = null,
    Object? score = null,
    Object? nextPeriod = freezed,
    Object? message = freezed,
  }) {
    return _then(_value.copyWith(
      currentPeriod: null == currentPeriod
          ? _value.currentPeriod
          : currentPeriod // ignore: cast_nullable_to_non_nullable
              as String,
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      nextPeriod: freezed == nextPeriod
          ? _value.nextPeriod
          : nextPeriod // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TimeFortuneWidgetDataImplCopyWith<$Res>
    implements $TimeFortuneWidgetDataCopyWith<$Res> {
  factory _$$TimeFortuneWidgetDataImplCopyWith(
          _$TimeFortuneWidgetDataImpl value,
          $Res Function(_$TimeFortuneWidgetDataImpl) then) =
      __$$TimeFortuneWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String currentPeriod,
      String score,
      String? nextPeriod,
      String? message});
}

/// @nodoc
class __$$TimeFortuneWidgetDataImplCopyWithImpl<$Res>
    extends _$TimeFortuneWidgetDataCopyWithImpl<$Res,
        _$TimeFortuneWidgetDataImpl>
    implements _$$TimeFortuneWidgetDataImplCopyWith<$Res> {
  __$$TimeFortuneWidgetDataImplCopyWithImpl(_$TimeFortuneWidgetDataImpl _value,
      $Res Function(_$TimeFortuneWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of TimeFortuneWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPeriod = null,
    Object? score = null,
    Object? nextPeriod = freezed,
    Object? message = freezed,
  }) {
    return _then(_$TimeFortuneWidgetDataImpl(
      currentPeriod: null == currentPeriod
          ? _value.currentPeriod
          : currentPeriod // ignore: cast_nullable_to_non_nullable
              as String,
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as String,
      nextPeriod: freezed == nextPeriod
          ? _value.nextPeriod
          : nextPeriod // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TimeFortuneWidgetDataImpl implements _TimeFortuneWidgetData {
  const _$TimeFortuneWidgetDataImpl(
      {required this.currentPeriod,
      required this.score,
      this.nextPeriod,
      this.message});

  factory _$TimeFortuneWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$TimeFortuneWidgetDataImplFromJson(json);

  @override
  final String currentPeriod;
  @override
  final String score;
  @override
  final String? nextPeriod;
  @override
  final String? message;

  @override
  String toString() {
    return 'TimeFortuneWidgetData(currentPeriod: $currentPeriod, score: $score, nextPeriod: $nextPeriod, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TimeFortuneWidgetDataImpl &&
            (identical(other.currentPeriod, currentPeriod) ||
                other.currentPeriod == currentPeriod) &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.nextPeriod, nextPeriod) ||
                other.nextPeriod == nextPeriod) &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, currentPeriod, score, nextPeriod, message);

  /// Create a copy of TimeFortuneWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TimeFortuneWidgetDataImplCopyWith<_$TimeFortuneWidgetDataImpl>
      get copyWith => __$$TimeFortuneWidgetDataImplCopyWithImpl<
          _$TimeFortuneWidgetDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TimeFortuneWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _TimeFortuneWidgetData implements TimeFortuneWidgetData {
  const factory _TimeFortuneWidgetData(
      {required final String currentPeriod,
      required final String score,
      final String? nextPeriod,
      final String? message}) = _$TimeFortuneWidgetDataImpl;

  factory _TimeFortuneWidgetData.fromJson(Map<String, dynamic> json) =
      _$TimeFortuneWidgetDataImpl.fromJson;

  @override
  String get currentPeriod;
  @override
  String get score;
  @override
  String? get nextPeriod;
  @override
  String? get message;

  /// Create a copy of TimeFortuneWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TimeFortuneWidgetDataImplCopyWith<_$TimeFortuneWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AvoidPeopleWidgetData _$AvoidPeopleWidgetDataFromJson(
    Map<String, dynamic> json) {
  return _AvoidPeopleWidgetData.fromJson(json);
}

/// @nodoc
mixin _$AvoidPeopleWidgetData {
  String? get warningType => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get advice => throw _privateConstructorUsedError;

  /// Serializes this AvoidPeopleWidgetData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AvoidPeopleWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AvoidPeopleWidgetDataCopyWith<AvoidPeopleWidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AvoidPeopleWidgetDataCopyWith<$Res> {
  factory $AvoidPeopleWidgetDataCopyWith(AvoidPeopleWidgetData value,
          $Res Function(AvoidPeopleWidgetData) then) =
      _$AvoidPeopleWidgetDataCopyWithImpl<$Res, AvoidPeopleWidgetData>;
  @useResult
  $Res call({String? warningType, String? description, String? advice});
}

/// @nodoc
class _$AvoidPeopleWidgetDataCopyWithImpl<$Res,
        $Val extends AvoidPeopleWidgetData>
    implements $AvoidPeopleWidgetDataCopyWith<$Res> {
  _$AvoidPeopleWidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AvoidPeopleWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? warningType = freezed,
    Object? description = freezed,
    Object? advice = freezed,
  }) {
    return _then(_value.copyWith(
      warningType: freezed == warningType
          ? _value.warningType
          : warningType // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      advice: freezed == advice
          ? _value.advice
          : advice // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AvoidPeopleWidgetDataImplCopyWith<$Res>
    implements $AvoidPeopleWidgetDataCopyWith<$Res> {
  factory _$$AvoidPeopleWidgetDataImplCopyWith(
          _$AvoidPeopleWidgetDataImpl value,
          $Res Function(_$AvoidPeopleWidgetDataImpl) then) =
      __$$AvoidPeopleWidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? warningType, String? description, String? advice});
}

/// @nodoc
class __$$AvoidPeopleWidgetDataImplCopyWithImpl<$Res>
    extends _$AvoidPeopleWidgetDataCopyWithImpl<$Res,
        _$AvoidPeopleWidgetDataImpl>
    implements _$$AvoidPeopleWidgetDataImplCopyWith<$Res> {
  __$$AvoidPeopleWidgetDataImplCopyWithImpl(_$AvoidPeopleWidgetDataImpl _value,
      $Res Function(_$AvoidPeopleWidgetDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of AvoidPeopleWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? warningType = freezed,
    Object? description = freezed,
    Object? advice = freezed,
  }) {
    return _then(_$AvoidPeopleWidgetDataImpl(
      warningType: freezed == warningType
          ? _value.warningType
          : warningType // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      advice: freezed == advice
          ? _value.advice
          : advice // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AvoidPeopleWidgetDataImpl implements _AvoidPeopleWidgetData {
  const _$AvoidPeopleWidgetDataImpl(
      {this.warningType, this.description, this.advice});

  factory _$AvoidPeopleWidgetDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$AvoidPeopleWidgetDataImplFromJson(json);

  @override
  final String? warningType;
  @override
  final String? description;
  @override
  final String? advice;

  @override
  String toString() {
    return 'AvoidPeopleWidgetData(warningType: $warningType, description: $description, advice: $advice)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AvoidPeopleWidgetDataImpl &&
            (identical(other.warningType, warningType) ||
                other.warningType == warningType) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.advice, advice) || other.advice == advice));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, warningType, description, advice);

  /// Create a copy of AvoidPeopleWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AvoidPeopleWidgetDataImplCopyWith<_$AvoidPeopleWidgetDataImpl>
      get copyWith => __$$AvoidPeopleWidgetDataImplCopyWithImpl<
          _$AvoidPeopleWidgetDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AvoidPeopleWidgetDataImplToJson(
      this,
    );
  }
}

abstract class _AvoidPeopleWidgetData implements AvoidPeopleWidgetData {
  const factory _AvoidPeopleWidgetData(
      {final String? warningType,
      final String? description,
      final String? advice}) = _$AvoidPeopleWidgetDataImpl;

  factory _AvoidPeopleWidgetData.fromJson(Map<String, dynamic> json) =
      _$AvoidPeopleWidgetDataImpl.fromJson;

  @override
  String? get warningType;
  @override
  String? get description;
  @override
  String? get advice;

  /// Create a copy of AvoidPeopleWidgetData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AvoidPeopleWidgetDataImplCopyWith<_$AvoidPeopleWidgetDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}
